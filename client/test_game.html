<!DOCTYPE html>
<html>
<head>
  <title>Test Game - Road Safety Simulator</title>
  <link rel="stylesheet" href="style.css">
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #game {
      display: block;
      width: 100%;
      height: 100vh;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 5px;
      text-align: center;
      z-index: 100;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  
  <div id="info">
    <div>Test Game - Street Road Model</div>
    <div id="status">Loading...</div>
  </div>
  
  <div id="controls">
    <div>W: Forward | S: Backward | A: Left | D: Right</div>
    <div>Mouse Wheel: Zoom In/Out | Left Click + Drag: Pan Left/Right/Up/Down (Rotate View) | Right/Middle Mouse: Move Camera</div>
  </div>

  <!-- Three.js -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    
    // Scene setup
    let scene, camera, renderer, controls;
    let streetRoad = null;
    let ground = null;
    let loader;
    
    // Infinite road system
    let roadSegments = [];
    let roadSegmentLength = 0;
    let lastCameraZ = 0;
    
    // Camera movement
    let keys = {};
    let mouseX = 0, mouseY = 0;
    let isMouseDown = false;
    
    function init() {
      // Initialize GLTFLoader
      loader = new GLTFLoader();
      
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // Sky blue
      
      // Create camera
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 5, 10);
      
      // Create renderer
      const canvas = document.getElementById("game");
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);
      
      // Load Street Road model
      loadStreetRoad();
      
      // Ground plane will be created after model loads to match model size
      
      // Event listeners
      window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
      window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
      window.addEventListener("resize", onWindowResize);
      
      // Mouse controls for zoom and perspective
      let isPanning = false;
      let isSwiping = false;
      let panStart = new THREE.Vector2();
      let zoomLevel = 75; // FOV for perspective camera
      
      // Mouse wheel for zoom in/out
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const zoomSpeed = 2;
        zoomLevel += e.deltaY * 0.01;
        zoomLevel = Math.max(10, Math.min(120, zoomLevel)); // Limit FOV between 10 and 120
        camera.fov = zoomLevel;
        camera.updateProjectionMatrix();
      });
      
      // Left mouse button for panning left/right (rotating camera)
      canvas.addEventListener("mousedown", (e) => {
        if (e.button === 0) { // Left mouse button
          isSwiping = true;
          panStart.set(e.clientX, e.clientY);
          e.preventDefault();
        } else if (e.button === 1 || e.button === 2) { // Middle or right mouse button
          isPanning = true;
          panStart.set(e.clientX, e.clientY);
          e.preventDefault();
        }
      });
      
      canvas.addEventListener("mousemove", (e) => {
        if (isSwiping) {
          // Left click drag: pan/rotate camera left/right and up/down
          const deltaX = e.clientX - panStart.x;
          const deltaY = e.clientY - panStart.y;
          const panSpeed = 0.005; // Rotation speed
          
          // Rotate camera left/right (yaw rotation around Y axis)
          camera.rotation.y -= deltaX * panSpeed;
          
          // Rotate camera up/down (pitch rotation around X axis)
          camera.rotation.x -= deltaY * panSpeed;
          
          // Limit pitch to prevent flipping (between -90 and 90 degrees)
          camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
          
          // Keep camera level (no roll)
          camera.rotation.z = 0;
          
          panStart.set(e.clientX, e.clientY);
        } else if (isPanning) {
          // Right/middle mouse: pan camera (move perpendicular to view direction)
          const deltaX = e.clientX - panStart.x;
          const deltaY = e.clientY - panStart.y;
          
          const panSpeed = 0.01;
          const right = new THREE.Vector3();
          camera.getWorldDirection(new THREE.Vector3());
          right.setFromMatrixColumn(camera.matrix, 0);
          const up = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 1);
          
          camera.position.add(right.multiplyScalar(-deltaX * panSpeed));
          camera.position.add(up.multiplyScalar(deltaY * panSpeed));
          
          panStart.set(e.clientX, e.clientY);
        }
      });
      
      canvas.addEventListener("mouseup", (e) => {
        if (e.button === 0) {
          isSwiping = false;
        } else if (e.button === 1 || e.button === 2) {
          isPanning = false;
        }
      });
      
      canvas.addEventListener("mouseleave", () => {
        isSwiping = false;
        isPanning = false;
      });
      
      // Prevent context menu on right click
      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });
      
      // Start animation
      animate();
    }
    
    function loadStreetRoad() {
      document.getElementById('status').textContent = 'Loading Street Road model...';
      
      // Set the path for loading textures and other resources
      loader.setPath('../assets/models/street_road/');
      
      // Try different possible paths
      const possiblePaths = [
        'scene.gltf',
        '../assets/models/street_road/scene.gltf',
        'assets/models/street_road/scene.gltf',
        './assets/models/street_road/scene.gltf'
      ];
      
      function tryLoadPath(pathIndex) {
        if (pathIndex >= possiblePaths.length) {
          document.getElementById('status').textContent = 'Error: Could not find model file';
          console.error('Tried all possible paths:', possiblePaths);
          return;
        }
        
        const modelPath = possiblePaths[pathIndex];
        console.log('Trying to load from:', modelPath);
        
        // Reset path for each attempt
        if (modelPath.includes('/')) {
          const pathParts = modelPath.split('/');
          pathParts.pop(); // Remove filename
          loader.setPath(pathParts.join('/') + '/');
        } else {
          loader.setPath('../assets/models/street_road/');
        }
        
        loader.load(
          modelPath.includes('/') ? modelPath.split('/').pop() : modelPath,
          function(gltf) {
            streetRoad = gltf.scene;
            
            // Enable shadows on all meshes
            streetRoad.traverse(function(child) {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                
                // Make sure materials are properly configured
                if (child.material) {
                  if (Array.isArray(child.material)) {
                    child.material.forEach(mat => {
                      if (mat) {
                        mat.needsUpdate = true;
                        // Enable proper rendering for textures
                        if (mat.map) mat.map.needsUpdate = true;
                        if (mat.normalMap) mat.normalMap.needsUpdate = true;
                      }
                    });
                  } else {
                    child.material.needsUpdate = true;
                    if (child.material.map) child.material.map.needsUpdate = true;
                    if (child.material.normalMap) child.material.normalMap.needsUpdate = true;
                  }
                }
              }
            });
            
            // Calculate bounding box to get model dimensions
            let box = new THREE.Box3().setFromObject(streetRoad);
            let size = box.getSize(new THREE.Vector3());
            const min = box.min;
            const max = box.max;
            
            console.log('Original model dimensions:', size);
            console.log('Model bounds - min:', min, 'max:', max);
            
            // Determine appropriate scale - aim for a reasonable road size (10-50 units)
            const maxDimension = Math.max(size.x, size.y, size.z);
            console.log('Max dimension:', maxDimension);
            
            // Scale model to a larger size (target: 50-100 units for largest dimension)
            let scale = 1;
            if (maxDimension > 100) {
              // Model is too large, scale it down but keep it big
              scale = 80 / maxDimension;
              streetRoad.scale.multiplyScalar(scale);
              console.log('Model scaled down by:', scale.toFixed(3));
              // Recalculate box after scaling
              box.setFromObject(streetRoad);
              size = box.getSize(new THREE.Vector3());
            } else if (maxDimension < 10) {
              // Model is too small, scale it up significantly
              scale = 80 / maxDimension;
              streetRoad.scale.multiplyScalar(scale);
              console.log('Model scaled up by:', scale.toFixed(3));
              // Recalculate box after scaling
              box.setFromObject(streetRoad);
              size = box.getSize(new THREE.Vector3());
            } else {
              // Model is in reasonable range, but make it larger
              scale = 80 / maxDimension;
              streetRoad.scale.multiplyScalar(scale);
              console.log('Model scaled to larger size by:', scale.toFixed(3));
              // Recalculate box after scaling
              box.setFromObject(streetRoad);
              size = box.getSize(new THREE.Vector3());
            }
            
            console.log('Final model dimensions:', size);
            
            // Make the road wider by scaling X axis (width) more than Y and Z
            const widthMultiplier = 3.0; // Make road 3x wider
            streetRoad.scale.x *= widthMultiplier;
            console.log('Road width scaled by:', widthMultiplier);
            
            // Recalculate box after width scaling
            box.setFromObject(streetRoad);
            size = box.getSize(new THREE.Vector3());
            console.log('Road dimensions after width scaling:', size);
            
            // Position the model on the ground plane
            const finalCenter = box.getCenter(new THREE.Vector3());
            const finalMin = box.min;
            
            // Move model so its bottom is at y=0 and centered on x and z
            streetRoad.position.x = -finalCenter.x;
            streetRoad.position.y = -finalMin.y;
            streetRoad.position.z = -finalCenter.z;
            
            scene.add(streetRoad);
            
            // Calculate road segment length and exact positioning for seamless connection
            // Recalculate box after positioning to get accurate bounds
            const positionedBox = new THREE.Box3().setFromObject(streetRoad);
            const positionedSize = positionedBox.getSize(new THREE.Vector3());
            const positionedMin = positionedBox.min;
            const positionedMax = positionedBox.max;
            
            // Calculate exact segment length based on actual model bounds
            roadSegmentLength = positionedSize.z;
            
            console.log('Road segment length:', roadSegmentLength);
            console.log('Road bounds - min Z:', positionedMin.z, 'max Z:', positionedMax.z);
            
            // Create one long continuous road by duplicating segments exactly adjacent
            // This creates a seamless road that looks like one continuous piece
            roadSegments = [streetRoad]; // Keep original as starting segment
            const numberOfSegments = 200; // Create 200 segments forward and backward (401 total) - expanded
            
            // Add segments going forward (exactly adjacent, no gaps)
            // Each segment's front edge connects to the previous segment's back edge
            let currentEndZ = positionedMax.z; // Start from the end of the original segment
            
            for (let i = 1; i <= numberOfSegments; i++) {
              const roadSegment = streetRoad.clone();
              roadSegment.position.x = streetRoad.position.x;
              roadSegment.position.y = streetRoad.position.y;
              
              // Get the bounding box of the cloned segment (before positioning)
              const segmentBox = new THREE.Box3().setFromObject(roadSegment);
              const segmentMinZ = segmentBox.min.z;
              
              // Position so the segment's front edge (min Z) aligns with the previous segment's back edge (max Z)
              roadSegment.position.z = currentEndZ - segmentMinZ;
              
              // Update the end position for the next segment
              segmentBox.setFromObject(roadSegment); // Recalculate after positioning
              currentEndZ = segmentBox.max.z;
              
              scene.add(roadSegment);
              roadSegments.push(roadSegment);
            }
            
            // Add segments going backward (exactly adjacent, no gaps)
            // Each segment's back edge connects to the previous segment's front edge
            let currentStartZ = positionedMin.z; // Start from the beginning of the original segment
            
            for (let i = 1; i <= numberOfSegments; i++) {
              const roadSegment = streetRoad.clone();
              roadSegment.position.x = streetRoad.position.x;
              roadSegment.position.y = streetRoad.position.y;
              
              // Get the bounding box of the cloned segment (before positioning)
              const segmentBox = new THREE.Box3().setFromObject(roadSegment);
              const segmentMaxZ = segmentBox.max.z;
              
              // Position so the segment's back edge (max Z) aligns with the previous segment's front edge (min Z)
              roadSegment.position.z = currentStartZ - segmentMaxZ;
              
              // Update the start position for the next segment
              segmentBox.setFromObject(roadSegment); // Recalculate after positioning
              currentStartZ = segmentBox.min.z;
              
              scene.add(roadSegment);
              roadSegments.push(roadSegment);
            }
            
            // Store initial camera Z position
            lastCameraZ = camera.position.z;
            
            console.log(`Long continuous road created: ${roadSegments.length} segments (${numberOfSegments * 2 + 1} total)`);
            
            // Create infinite ground plane (very large)
            const groundGeometry = new THREE.PlaneGeometry(10000, 10000);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x90EE90 });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1; // Slightly below road surface
            ground.receiveShadow = true;
            scene.add(ground);
            
            console.log('Infinite ground plane created (10000x10000)');
            
            // Position camera at eye level on the road (first-person walking view)
            const roadLength = Math.max(size.x, size.z);
            const roadHeight = size.y;
            
            // Eye level height (typical human eye height: ~1.6-1.8 meters)
            const eyeLevel = 1.7; // 1.7 units = ~1.7 meters
            
            // Position camera on the road surface at eye level
            // Place camera at the start of the road, centered on X axis
            const startZ = Math.min(0, -roadLength * 0.3); // Start position on road
            
            // Camera positioned on the road at eye level, looking forward
            camera.position.set(0, eyeLevel, startZ);
            
            // Set initial rotation to look forward along the road (no tilting)
            camera.rotation.set(0, 0, 0); // Look straight ahead, no pitch or roll
            
            console.log('Camera positioned at:', camera.position);
            console.log('Model positioned at:', streetRoad.position);
            console.log('✅ Road model is properly sized and positioned on ground plane');
            
            document.getElementById('status').textContent = 'Street Road loaded successfully!';
            console.log('✅ Street Road model loaded:', streetRoad);
            console.log('Final model size:', size);
            console.log('Model position:', streetRoad.position);
            console.log('Camera view: First-person walking view on the road');
          },
          function(progress) {
            if (progress.lengthComputable) {
              const percent = (progress.loaded / progress.total * 100).toFixed(0);
              document.getElementById('status').textContent = `Loading: ${percent}%`;
              console.log('Loading progress:', percent + '%');
            } else {
              document.getElementById('status').textContent = 'Loading model...';
            }
          },
          function(error) {
            console.error('Error loading from', modelPath, ':', error);
            // Try next path
            tryLoadPath(pathIndex + 1);
          }
        );
      }
      
      // Start trying paths
      tryLoadPath(0);
    }
    
    function updateCamera() {
      const moveSpeed = 0.1; // Walking speed
      const eyeLevel = 1.7; // Keep at eye level
      
      // Get camera's forward direction (always forward along Z axis, no tilting)
      const forward = new THREE.Vector3(0, 0, -1);
      const right = new THREE.Vector3(1, 0, 0);
      
      // W: Move forward
      if (keys['w'] || keys['arrowup']) {
        camera.position.add(forward.clone().multiplyScalar(moveSpeed));
      }
      
      // S: Move backward
      if (keys['s'] || keys['arrowdown']) {
        camera.position.add(forward.clone().multiplyScalar(-moveSpeed));
      }
      
      // A: Move left (strafe left)
      if (keys['a'] || keys['arrowleft']) {
        camera.position.add(right.clone().multiplyScalar(-moveSpeed));
      }
      
      // D: Move right (strafe right)
      if (keys['d'] || keys['arrowright']) {
        camera.position.add(right.clone().multiplyScalar(moveSpeed));
      }
      
      // Keep camera at eye level and prevent tilting
      camera.position.y = eyeLevel;
      camera.rotation.x = 0; // No pitch (prevent tilting)
      camera.rotation.z = 0; // No roll (prevent tilting)
      
      // No need for dynamic repositioning - we have a long continuous road
      // The road is long enough (201 segments) to appear infinite for driving simulation
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animate() {
      requestAnimationFrame(animate);
      updateCamera();
      renderer.render(scene, camera);
    }
    
    // Initialize when page loads
    window.addEventListener('load', () => {
      setTimeout(() => {
        init();
      }, 100);
    });
  </script>
</body>
</html>
