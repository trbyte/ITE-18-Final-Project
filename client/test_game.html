<!DOCTYPE html>
<html>
<head>
  <title>Test Game - Road Safety Simulator</title>
  <link rel="stylesheet" href="style.css">
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #game {
      display: block;
      width: 100%;
      height: 100vh;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 5px;
      text-align: center;
      z-index: 100;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  
  <div id="info">
    <div>Test Game - Street Road Model</div>
    <div id="status">Loading...</div>
  </div>
  
  <div id="controls">
    <div>W: Forward | S: Backward | A: Left | D: Right</div>
    <div>Mouse Wheel: Zoom In/Out | Left Click + Drag: Pan Left/Right/Up/Down (Rotate View) | Right/Middle Mouse: Move Camera</div>
  </div>

  <!-- Three.js -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    
    let scene, camera, renderer;
    let streetRoad = null;
    let ground = null;
    let loader;
    let roadSegments = [];
    let localMinZOffset = 0;
    let localMaxZOffset = 0;
    const segmentOverlap = 0.9;
    let keys = {};
    
    function init() {
      loader = new GLTFLoader();
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 10);
      
      const canvas = document.getElementById("game");
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);
      
      loadStreetRoad();
      
      window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
      window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
      window.addEventListener("resize", onWindowResize);
      
      let isPanning = false;
      let isSwiping = false;
      let panStart = new THREE.Vector2();
      let zoomLevel = 75;
      
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        zoomLevel += e.deltaY * 0.01;
        zoomLevel = Math.max(10, Math.min(120, zoomLevel));
        camera.fov = zoomLevel;
        camera.updateProjectionMatrix();
      });
      
      canvas.addEventListener("mousedown", (e) => {
        if (e.button === 0) {
          isSwiping = true;
          panStart.set(e.clientX, e.clientY);
          e.preventDefault();
        } else if (e.button === 1 || e.button === 2) {
          isPanning = true;
          panStart.set(e.clientX, e.clientY);
          e.preventDefault();
        }
      });
      
      canvas.addEventListener("mousemove", (e) => {
        if (isSwiping) {
          const deltaX = e.clientX - panStart.x;
          const deltaY = e.clientY - panStart.y;
          const panSpeed = 0.005;
          
          camera.rotation.y -= deltaX * panSpeed;
          camera.rotation.x -= deltaY * panSpeed;
          camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
          camera.rotation.z = 0;
          
          panStart.set(e.clientX, e.clientY);
        } else if (isPanning) {
          const deltaX = e.clientX - panStart.x;
          const deltaY = e.clientY - panStart.y;
          const panSpeed = 0.01;
          const right = new THREE.Vector3();
          camera.getWorldDirection(new THREE.Vector3());
          right.setFromMatrixColumn(camera.matrix, 0);
          const up = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 1);
          
          camera.position.add(right.multiplyScalar(-deltaX * panSpeed));
          camera.position.add(up.multiplyScalar(deltaY * panSpeed));
          
          panStart.set(e.clientX, e.clientY);
        }
      });
      
      canvas.addEventListener("mouseup", (e) => {
        if (e.button === 0) {
          isSwiping = false;
        } else if (e.button === 1 || e.button === 2) {
          isPanning = false;
        }
      });
      
      canvas.addEventListener("mouseleave", () => {
        isSwiping = false;
        isPanning = false;
      });
      
      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });
      
      animate();
    }
    
    function loadStreetRoad() {
      document.getElementById('status').textContent = 'Loading Street Road model...';
      loader.setPath('../assets/models/street_road/');
      
      const possiblePaths = [
        'scene.gltf',
        '../assets/models/street_road/scene.gltf',
        'assets/models/street_road/scene.gltf',
        './assets/models/street_road/scene.gltf'
      ];
      
      function tryLoadPath(pathIndex) {
        if (pathIndex >= possiblePaths.length) {
          document.getElementById('status').textContent = 'Error: Could not find model file';
          return;
        }
        
        const modelPath = possiblePaths[pathIndex];
        
        if (modelPath.includes('/')) {
          const pathParts = modelPath.split('/');
          pathParts.pop();
          loader.setPath(pathParts.join('/') + '/');
        } else {
          loader.setPath('../assets/models/street_road/');
        }
        
        loader.load(
          modelPath.includes('/') ? modelPath.split('/').pop() : modelPath,
          function(gltf) {
            streetRoad = gltf.scene;
            
            streetRoad.traverse(function(child) {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                
                if (child.material) {
                  if (Array.isArray(child.material)) {
                    child.material.forEach(mat => {
                      if (mat) {
                        mat.needsUpdate = true;
                        if (mat.map) mat.map.needsUpdate = true;
                        if (mat.normalMap) mat.normalMap.needsUpdate = true;
                      }
                    });
                  } else {
                    child.material.needsUpdate = true;
                    if (child.material.map) child.material.map.needsUpdate = true;
                    if (child.material.normalMap) child.material.normalMap.needsUpdate = true;
                  }
                }
              }
            });
            
            let box = new THREE.Box3().setFromObject(streetRoad);
            let size = box.getSize(new THREE.Vector3());
            const maxDimension = Math.max(size.x, size.y, size.z);
            
            const scale = 80 / maxDimension;
            streetRoad.scale.multiplyScalar(scale);
            box.setFromObject(streetRoad);
            size = box.getSize(new THREE.Vector3());
            
            streetRoad.scale.x *= 3.0;
            box.setFromObject(streetRoad);
            size = box.getSize(new THREE.Vector3());
            
            const finalCenter = box.getCenter(new THREE.Vector3());
            const finalMin = box.min;
            
            streetRoad.position.x = -finalCenter.x;
            streetRoad.position.y = -finalMin.y;
            streetRoad.position.z = -finalCenter.z;
            
            scene.add(streetRoad);
            
            const positionedBox = new THREE.Box3().setFromObject(streetRoad);
            const positionedMax = positionedBox.max;
            
            const localBox = new THREE.Box3().setFromObject(streetRoad);
            localMinZOffset = localBox.min.z - streetRoad.position.z;
            localMaxZOffset = localBox.max.z - streetRoad.position.z;
            
            roadSegments = [streetRoad];
            const numberOfSegments = 30;
            let currentEndZ = positionedMax.z;
            
            for (let i = 1; i < numberOfSegments; i++) {
              const roadSegment = streetRoad.clone();
              roadSegment.position.x = streetRoad.position.x;
              roadSegment.position.y = streetRoad.position.y;
              roadSegment.position.z = currentEndZ - segmentOverlap - localMinZOffset;
              currentEndZ = roadSegment.position.z + localMaxZOffset;
              
              scene.add(roadSegment);
              roadSegments.push(roadSegment);
            }
            
            const groundGeometry = new THREE.PlaneGeometry(10000, 10000);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x90EE90 });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);
            
            const roadLength = Math.max(size.x, size.z);
            const eyeLevel = 1.7;
            const startZ = Math.min(0, -roadLength * 0.3);
            
            camera.position.set(0, eyeLevel, startZ);
            camera.rotation.set(0, Math.PI, 0);
            
            document.getElementById('status').textContent = 'Street Road loaded successfully!';
          },
          function(progress) {
            if (progress.lengthComputable) {
              const percent = (progress.loaded / progress.total * 100).toFixed(0);
              document.getElementById('status').textContent = `Loading: ${percent}%`;
            } else {
              document.getElementById('status').textContent = 'Loading model...';
            }
          },
          function(error) {
            tryLoadPath(pathIndex + 1);
          }
        );
      }
      
      // Start trying paths
      tryLoadPath(0);
    }
    
    function updateCamera() {
      const moveSpeed = 0.1;
      const eyeLevel = 1.7;
      const forward = new THREE.Vector3(0, 0, 1);
      const right = new THREE.Vector3(1, 0, 0);
      
      if (keys['w'] || keys['arrowup']) {
        camera.position.add(forward.clone().multiplyScalar(moveSpeed));
      }
      if (keys['s'] || keys['arrowdown']) {
        camera.position.add(forward.clone().multiplyScalar(-moveSpeed));
      }
      if (keys['a'] || keys['arrowleft']) {
        camera.position.add(right.clone().multiplyScalar(-moveSpeed));
      }
      if (keys['d'] || keys['arrowright']) {
        camera.position.add(right.clone().multiplyScalar(moveSpeed));
      }
      
      camera.position.y = eyeLevel;
      camera.rotation.x = 0;
      camera.rotation.z = 0;
      
      if (roadSegments.length > 0) {
        const cameraZ = camera.position.z;
        const recycleThreshold = 5;
        
        for (let i = 0; i < roadSegments.length; i++) {
          const segment = roadSegments[i];
          const segmentBox = new THREE.Box3().setFromObject(segment);
          const segmentMaxZ = segmentBox.max.z;
          
          if (segmentMaxZ < cameraZ - recycleThreshold) {
            let frontmostZ = -Infinity;
            for (let j = 0; j < roadSegments.length; j++) {
              if (j !== i) {
                const otherBox = new THREE.Box3().setFromObject(roadSegments[j]);
                if (otherBox.max.z > frontmostZ) {
                  frontmostZ = otherBox.max.z;
                }
              }
            }
            
            segment.position.z = frontmostZ - segmentOverlap - localMinZOffset;
            segment.position.x = roadSegments[0].position.x;
            segment.position.y = roadSegments[0].position.y;
          }
        }
      }
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animate() {
      requestAnimationFrame(animate);
      updateCamera();
      renderer.render(scene, camera);
    }
    
    window.addEventListener('load', () => {
      init();
    });
  </script>
</body>
</html>
